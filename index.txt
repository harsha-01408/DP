CODERE3 - Coder Express 3!!
#dynamic-programming #lds

There are N buildings in a line, each with a given height. Find the maximum length of a subsequence of buildings that first strictly increases and then strictly decreases (i.e., a bitonic subsequence with a single peak).

Input
The first line contains an integer T (1 ≤ T ≤ 100) — the number of test cases.
For each test case:
- A line with integer N (1 ≤ N ≤ 1000).
- A line with N integers A1, A2, …, AN (1 ≤ Ai ≤ 1000) — the heights.

Output
For each test case, print a single line with the maximum possible length of such a subsequence.

Example
Input:
2
10
1 3 5 6 4 8 4 3 2 1
6
8 6 3 4 2 1

Output:
9
5

Explanation
Test 1: One optimal subsequence is 1 3 5 6 8 4 3 2 1 (length 9).
Test 2: One optimal subsequence is 8 6 4 2 1 (length 5).



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Partition

You are given an array A of N integers (1-based indexing). You may split the array into any number K (K ≥ 1) of
contiguous partitions so that together they cover the whole array in order.

If the partition sums are P1, P2, …, PK, define the “special sum” of the partitioning as:
    P1 − P2 + P3 − P4 + … + (−1)^(K−1) · PK
(i.e., start with +, then alternate −, +, −, …).

Task
Choose a partitioning that maximizes the special sum and output that maximum value.

Notes
• Partitions must be contiguous and in order (no reordering of elements).
• 1-based indexing is assumed in any explanation.

Input Format
• The first line contains an integer N.
• The second line contains N space-separated integers A1, A2, …, AN.

Output Format
• Print a single integer: the maximum achievable special sum.

Constraints
• 1 ≤ N ≤ 10^5
• −10^5 ≤ Ai ≤ 10^6  for all i in [1, N]

Example
Input
5
-1 -2 3 2 9

Output
9

Explanation
One optimal partitioning is: [−1] | [−2, 3] | [2, 9]
Here, P1 = −1, P2 = (−2 + 3) = 1, P3 = (2 + 9) = 11
Special sum = P1 − P2 + P3 = (−1) − 1 + 11 = 9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The Abandoned City

You have N houses in a straight line; house i contains coins[i] (all positive).
You may start at any house and walk only in one direction (left or right) without
changing direction, stopping at any house. While walking, you collect coins from
every house you pass (including start and stop).

Find the **shortest distance** you must walk to collect **at least T coins**.
(“Distance” = number of houses visited = length of that contiguous segment.)
If it’s impossible (total coins < T), return -1.

Example:
coins = [1,2,3,4,5], T = 7
Minimum houses = 2 (e.g., houses [3,4] → 3+4=7).

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Strength After One Segment Swap

You are given two integer arrays A and B of equal length n. A superhero’s strength is 0 initially.
He will finally pick exactly ONE of the two arrays (after an optional operation described below)
and add up all elements of that chosen array — that total is his strength.

Before choosing the array, he may perform AT MOST ONE operation:
- Choose indices l and r (0 ≤ l ≤ r < n), and swap the subarray A[l..r] with B[l..r]
  (i.e., for every i in [l, r], swap A[i] and B[i]).

He can do this operation once or skip it. After that, he chooses either the resulting A or the
resulting B and his strength is the sum of all elements in that chosen array.

Task
Return the maximum possible strength he can obtain.

Input Format
- Line 1: integer n — length of the arrays.
- Line 2: n space-separated integers — A[0..n−1].
- Line 3: n space-separated integers — B[0..n−1].

Output Format
- A single integer: the maximum total obtainable after at most one subarray swap and then
  choosing the better of the two arrays.

Constraints
- 1 ≤ n ≤ 10^5
- 1 ≤ A[i], B[i] ≤ 10^4
- A and B have the same length.

Sample Input
5
20 40 20 70 30
50 20 50 40 20

Sample Output
220

Explanation
Swap the segment l=3, r=4 (0-based):
A becomes [20, 40, 20, 40, 20]  → sum = 140
B becomes [50, 20, 50, 70, 30]  → sum = 220
Choose B; maximum strength = 220.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Interleaving Subsequences Count

Given three lowercase strings p, q, and r (length ≤ 100), count the number of ways to form
exactly the string r by interleaving a subsequence of p and a subsequence of q, while
preserving the relative order of characters taken from each string. You must use at least
one character from p and at least one character from q. Return the answer modulo 1,000,000,007.

Notes
- “Subsequence” means you may skip characters but cannot reorder them.
- The two chosen subsequences (one from p, one from q) are interleaved to form r.
- At least one character must be taken from each of p and q.

Input Format
- Line 1: string p
- Line 2: string q
- Line 3: string r

Output Format
- A single integer: the number of valid interleavings modulo 1,000,000,007.

Constraints
- 1 ≤ |p|, |q|, |r| ≤ 100
- All strings consist only of lowercase English letters.

Sample
p: ab
q: ba
r: aba

Output:
2

Explanation:
Two valid ways to form "aba":
1) take "a" from p, then "ba" from q
2) take "ab" from p, then "a" from q

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Mortal Kombat — Max Coins

You are playing a simplified Mortal Kombat. You have:
• Your health: h
• Your per-hit damage: d

There are k opponents. For each opponent i (0 ≤ i < k):
• health hp[i]
• per-hit damage dmg[i]

Combat rules
• You may choose which opponents to fight and in what order. You can fight each opponent at most once.
• Fights are 1v1 and turn-based; YOU STRIKE FIRST in each turn.
  - On your turn, you deal d damage to the current opponent.
  - If the opponent is still alive, they strike back and deal dmg[i] damage to you.
  - Repeat until either you or the opponent dies.
• If you kill an opponent with health m, you earn m coins.
• The game ends immediately when your health becomes ≤ 0 (you die). You cannot start a new fight after that.

Task
Determine the maximum total number of coins you can earn by choosing a subset of opponents and an order to fight them, subject to not dying before finishing those fights.

Input Format
• First line: three integers h d k
• Second line: k integers hp[0..k-1]
• Third line: k integers dmg[0..k-1]

Output Format
• A single integer: the maximum coins obtainable.

Notes
• To kill opponent i you need hits_i = ceil(hp[i] / d) of your attacks.
• Since you strike first, they retaliate exactly hits_i − 1 times if you win.
• Thus, fighting i costs you (hits_i − 1) * dmg[i] health and yields hp[i] coins.
• You must remain alive before delivering each killing blow; equivalently, the total health you can afford to lose across chosen fights is at most h − 1.

Constraints
• 1 ≤ k ≤ 2 · 10^5  (typical; adjust as needed)
• 1 ≤ h, d ≤ 10^9
• 1 ≤ hp[i], dmg[i] ≤ 10^9

Example (illustrative)
h = 10, d = 4, k = 3
hp = 5 9 3
dmg = 3 4 10
Answer: 14
Explanation: Fight opponents with hp 5 and 9 (in that order). Costs: (ceil(5/4)-1)*3 = 3,
then (ceil(9/4)-1)*4 = 8; total cost 11 would kill you if done second first, so order matters.
The best feasible subset/order yields 5 + 9 = 14 coins.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Counting Jumps with B % (B − A) = 0

You can jump from an integer A to a larger integer B (A < B) iff:
    B % (B − A) = 0
(where % is modulo).

Starting from 1, count the number of distinct sequences of jumps to reach N.
Two sequences are different if at some step they go to different integers.

Because the count can be large, output it modulo 1,000,000,007.

Input Format
• The first line contains an integer T — the number of test cases.
• Each of the next T lines contains a single integer N.

Output Format
• For each test case, print the number of ways to reach N from 1 (mod 1e9+7).

Constraints
• 1 ≤ T ≤ 10000
• 1 ≤ N ≤ 100000

Notes
• The move rule is equivalent to: from x you may go to x + d for any divisor d of x.

Example
Input
4
1
2
3
4
Output
1
1
1
2
Explanation
N=1: already at 1 → 1 way.
N=2: 1→2.
N=3: 1→2→3 (1→3 is invalid since 3%(2)≠0).
N=4: paths are 1→2→4 and 1→2→3→4 → 2 ways.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Count Matching Subsequence Pairs

You are given two sequences:
• A of length N: A1 A2 … AN
• B of length M: B1 B2 … BM

A subsequence of a sequence is obtained by deleting zero or more elements without
changing the order of the remaining elements. Two subsequences taken from the
SAME sequence are considered different if they use different index positions,
even if their values are identical (i.e., we count by index choices). The empty
subsequence is allowed.

Task
Count the number of pairs (A_seq, B_seq) such that:
• A_seq is a subsequence of A,
• B_seq is a subsequence of B, and
• A_seq and B_seq are exactly the same sequence (same length and same elements
  in the same order).

Output the count modulo 1,000,000,007.

Input Format
• First line: two integers N M
• Second line: N integers A1 … AN
• Third line:  M integers B1 … BM

Constraints
• 1 ≤ N, M ≤ 3×10^3
• 1 ≤ Ai, Bi ≤ 10^5
• All values are integers.

Output Format
• Print a single integer — the number of valid pairs modulo 1e9+7.

Example
Input
2 2
2 7
7 2
Output
3
Explanation: Matching subsequences are (), (2), (7).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
