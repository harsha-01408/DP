CODERE3 - Coder Express 3!!
#dynamic-programming #lds

There are N buildings in a line, each with a given height. Find the maximum length of a subsequence of buildings that first strictly increases and then strictly decreases (i.e., a bitonic subsequence with a single peak).

Input
The first line contains an integer T (1 ≤ T ≤ 100) — the number of test cases.
For each test case:
- A line with integer N (1 ≤ N ≤ 1000).
- A line with N integers A1, A2, …, AN (1 ≤ Ai ≤ 1000) — the heights.

Output
For each test case, print a single line with the maximum possible length of such a subsequence.

Example
Input:
2
10
1 3 5 6 4 8 4 3 2 1
6
8 6 3 4 2 1

Output:
9
5

Explanation
Test 1: One optimal subsequence is 1 3 5 6 8 4 3 2 1 (length 9).
Test 2: One optimal subsequence is 8 6 4 2 1 (length 5).



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Partition

You are given an array A of N integers (1-based indexing). You may split the array into any number K (K ≥ 1) of
contiguous partitions so that together they cover the whole array in order.

If the partition sums are P1, P2, …, PK, define the “special sum” of the partitioning as:
    P1 − P2 + P3 − P4 + … + (−1)^(K−1) · PK
(i.e., start with +, then alternate −, +, −, …).

Task
Choose a partitioning that maximizes the special sum and output that maximum value.

Notes
• Partitions must be contiguous and in order (no reordering of elements).
• 1-based indexing is assumed in any explanation.

Input Format
• The first line contains an integer N.
• The second line contains N space-separated integers A1, A2, …, AN.

Output Format
• Print a single integer: the maximum achievable special sum.

Constraints
• 1 ≤ N ≤ 10^5
• −10^5 ≤ Ai ≤ 10^6  for all i in [1, N]

Example
Input
5
-1 -2 3 2 9

Output
9

Explanation
One optimal partitioning is: [−1] | [−2, 3] | [2, 9]
Here, P1 = −1, P2 = (−2 + 3) = 1, P3 = (2 + 9) = 11
Special sum = P1 − P2 + P3 = (−1) − 1 + 11 = 9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The Abandoned City

You have N houses in a straight line; house i contains coins[i] (all positive).
You may start at any house and walk only in one direction (left or right) without
changing direction, stopping at any house. While walking, you collect coins from
every house you pass (including start and stop).

Find the **shortest distance** you must walk to collect **at least T coins**.
(“Distance” = number of houses visited = length of that contiguous segment.)
If it’s impossible (total coins < T), return -1.

Example:
coins = [1,2,3,4,5], T = 7
Minimum houses = 2 (e.g., houses [3,4] → 3+4=7).

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Strength After One Segment Swap

You are given two integer arrays A and B of equal length n. A superhero’s strength is 0 initially.
He will finally pick exactly ONE of the two arrays (after an optional operation described below)
and add up all elements of that chosen array — that total is his strength.

Before choosing the array, he may perform AT MOST ONE operation:
- Choose indices l and r (0 ≤ l ≤ r < n), and swap the subarray A[l..r] with B[l..r]
  (i.e., for every i in [l, r], swap A[i] and B[i]).

He can do this operation once or skip it. After that, he chooses either the resulting A or the
resulting B and his strength is the sum of all elements in that chosen array.

Task
Return the maximum possible strength he can obtain.

Input Format
- Line 1: integer n — length of the arrays.
- Line 2: n space-separated integers — A[0..n−1].
- Line 3: n space-separated integers — B[0..n−1].

Output Format
- A single integer: the maximum total obtainable after at most one subarray swap and then
  choosing the better of the two arrays.

Constraints
- 1 ≤ n ≤ 10^5
- 1 ≤ A[i], B[i] ≤ 10^4
- A and B have the same length.

Sample Input
5
20 40 20 70 30
50 20 50 40 20

Sample Output
220

Explanation
Swap the segment l=3, r=4 (0-based):
A becomes [20, 40, 20, 40, 20]  → sum = 140
B becomes [50, 20, 50, 70, 30]  → sum = 220
Choose B; maximum strength = 220.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Interleaving Subsequences Count

Given three lowercase strings p, q, and r (length ≤ 100), count the number of ways to form
exactly the string r by interleaving a subsequence of p and a subsequence of q, while
preserving the relative order of characters taken from each string. You must use at least
one character from p and at least one character from q. Return the answer modulo 1,000,000,007.

Notes
- “Subsequence” means you may skip characters but cannot reorder them.
- The two chosen subsequences (one from p, one from q) are interleaved to form r.
- At least one character must be taken from each of p and q.

Input Format
- Line 1: string p
- Line 2: string q
- Line 3: string r

Output Format
- A single integer: the number of valid interleavings modulo 1,000,000,007.

Constraints
- 1 ≤ |p|, |q|, |r| ≤ 100
- All strings consist only of lowercase English letters.

Sample
p: ab
q: ba
r: aba

Output:
2

Explanation:
Two valid ways to form "aba":
1) take "a" from p, then "ba" from q
2) take "ab" from p, then "a" from q

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Mortal Kombat — Max Coins

You are playing a simplified Mortal Kombat. You have:
• Your health: h
• Your per-hit damage: d

There are k opponents. For each opponent i (0 ≤ i < k):
• health hp[i]
• per-hit damage dmg[i]

Combat rules
• You may choose which opponents to fight and in what order. You can fight each opponent at most once.
• Fights are 1v1 and turn-based; YOU STRIKE FIRST in each turn.
  - On your turn, you deal d damage to the current opponent.
  - If the opponent is still alive, they strike back and deal dmg[i] damage to you.
  - Repeat until either you or the opponent dies.
• If you kill an opponent with health m, you earn m coins.
• The game ends immediately when your health becomes ≤ 0 (you die). You cannot start a new fight after that.

Task
Determine the maximum total number of coins you can earn by choosing a subset of opponents and an order to fight them, subject to not dying before finishing those fights.

Input Format
• First line: three integers h d k
• Second line: k integers hp[0..k-1]
• Third line: k integers dmg[0..k-1]

Output Format
• A single integer: the maximum coins obtainable.

Notes
• To kill opponent i you need hits_i = ceil(hp[i] / d) of your attacks.
• Since you strike first, they retaliate exactly hits_i − 1 times if you win.
• Thus, fighting i costs you (hits_i − 1) * dmg[i] health and yields hp[i] coins.
• You must remain alive before delivering each killing blow; equivalently, the total health you can afford to lose across chosen fights is at most h − 1.

Constraints
• 1 ≤ k ≤ 2 · 10^5  (typical; adjust as needed)
• 1 ≤ h, d ≤ 10^9
• 1 ≤ hp[i], dmg[i] ≤ 10^9

Example (illustrative)
h = 10, d = 4, k = 3
hp = 5 9 3
dmg = 3 4 10
Answer: 14
Explanation: Fight opponents with hp 5 and 9 (in that order). Costs: (ceil(5/4)-1)*3 = 3,
then (ceil(9/4)-1)*4 = 8; total cost 11 would kill you if done second first, so order matters.
The best feasible subset/order yields 5 + 9 = 14 coins.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Counting Jumps with B % (B − A) = 0

You can jump from an integer A to a larger integer B (A < B) iff:
    B % (B − A) = 0
(where % is modulo).

Starting from 1, count the number of distinct sequences of jumps to reach N.
Two sequences are different if at some step they go to different integers.

Because the count can be large, output it modulo 1,000,000,007.

Input Format
• The first line contains an integer T — the number of test cases.
• Each of the next T lines contains a single integer N.

Output Format
• For each test case, print the number of ways to reach N from 1 (mod 1e9+7).

Constraints
• 1 ≤ T ≤ 10000
• 1 ≤ N ≤ 100000

Notes
• The move rule is equivalent to: from x you may go to x + d for any divisor d of x.

Example
Input
4
1
2
3
4
Output
1
1
1
2
Explanation
N=1: already at 1 → 1 way.
N=2: 1→2.
N=3: 1→2→3 (1→3 is invalid since 3%(2)≠0).
N=4: paths are 1→2→4 and 1→2→3→4 → 2 ways.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Count Matching Subsequence Pairs

You are given two sequences:
• A of length N: A1 A2 … AN
• B of length M: B1 B2 … BM

A subsequence of a sequence is obtained by deleting zero or more elements without
changing the order of the remaining elements. Two subsequences taken from the
SAME sequence are considered different if they use different index positions,
even if their values are identical (i.e., we count by index choices). The empty
subsequence is allowed.

Task
Count the number of pairs (A_seq, B_seq) such that:
• A_seq is a subsequence of A,
• B_seq is a subsequence of B, and
• A_seq and B_seq are exactly the same sequence (same length and same elements
  in the same order).

Output the count modulo 1,000,000,007.

Input Format
• First line: two integers N M
• Second line: N integers A1 … AN
• Third line:  M integers B1 … BM

Constraints
• 1 ≤ N, M ≤ 3×10^3
• 1 ≤ Ai, Bi ≤ 10^5
• All values are integers.

Output Format
• Print a single integer — the number of valid pairs modulo 1e9+7.

Example
Input
2 2
2 7
7 2
Output
3
Explanation: Matching subsequences are (), (2), (7).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Construction Management (Paint House)

You are given a row of n houses. Each house must be built using exactly one of
three materials (A, B, or C). Adjacent houses may NOT use the same material.

For each house i (1 ≤ i ≤ n) you are given three integers:
  cost[i][0] = cost to build house i with material A
  cost[i][1] = cost to build house i with material B
  cost[i][2] = cost to build house i with material C

Task:
Choose a material for every house so that adjacent houses use different
materials and the total cost is minimized. Return the minimum total cost.

Input format
- First line: integer n
- Next n lines: three integers cost[i][0] cost[i][1] cost[i][2]

Output format
- One integer: the minimum total cost to build all houses.

Sample Input
3
17 2 17
16 16 5
14 3 19

Sample Output
10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Maximum Nutrition with Coupons

You have m units of money and n fruit varieties. For each fruit i (0 ≤ i < n):
  price[i]      – its cost (integer)
  nutrition[i]  – its nutrition value (integer)

You also have k discount coupons. A coupon can be applied to at most one fruit
and allows buying that fruit at half price (i.e., floor(price[i] / 2)).
Each fruit can be bought at most once, and at most one coupon can be used per fruit.

Task:
Choose a subset of fruits to buy and decide which (up to k) of them use a
coupon so that the total spent ≤ m and the sum of nutrition values is maximized.
Return that maximum total nutrition.

Input format
- First line: integer m
- Second line: integer n
- Third line: n space-separated integers price[0..n-1]
- Fourth line: n space-separated integers nutrition[0..n-1]
- Fifth line: integer k

Output format
- One integer: the maximum total nutrition achievable within budget m.

Constraints
1 ≤ m ≤ 10^3
1 ≤ n ≤ 500
1 ≤ price[i], nutrition[i] ≤ 10^3
0 ≤ k ≤ 10

Example 1
m = 4
n = 3
price      = [2, 4, 5]
nutrition  = [20, 17, 15]
k = 1
Optimal: buy fruit with price 2 at full price and fruit with price 4 using a
coupon (cost 2). Total cost = 2 + 2 = 4, total nutrition = 20 + 17 = 37.
Answer: 37

Example 2
m = 10
n = 2
price      = [10, 20]
nutrition  = [9, 10]
k = 1
Optimal: buy fruit 0 using a coupon (cost 5) and fruit 1 at full price (cost 10)
is too expensive; best is buy fruit 0 at full price (10) → nutrition 9, or use
coupon on fruit 1 (10) → nutrition 10. Maximum nutrition = 10.
Answer: 10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Element Swapping

Given an array arr of n integers, you may perform the following operation any number of times:
1) Choose an index i (0 ≤ i < n − 1) and swap arr[i] and arr[i + 1].
2) Each element can be swapped at most once during the whole process (i.e., no element participates in more than one swap).

The strength of index i is defined as arr[i] × (i + 1), using 0-based indexing.

Goal:
Find the maximum possible value of
    S = Σ_{i=0}^{n−1} arr[i] × (i + 1)
after applying allowed swaps optimally. Return this maximum.

Example
n = 4
arr = [2, 1, 4, 3]

Optimal swaps:
- swap(arr[2], arr[3])
- swap(arr[0], arr[1])

Final array: [1, 2, 3, 4]
Sum of strengths: 1×1 + 2×2 + 3×3 + 4×4 = 30
Return 30.

Function Description
Complete the function getMaximumSumOfStrengths with the parameter:
    int arr[n]: the initial array
Returns:
    long int: the maximum possible sum of strengths of all indices after optimal swaps.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Select Stock — Max Profit with Budget (0/1 Knapsack)

You have N stocks and a budget `saving`. You may buy at most ONE share of each
stock now at price `currentValue[i]`. After one year, stock i will be worth
`futureValue[i]`. If you buy stock i, your profit is:

    profit[i] = futureValue[i] - currentValue[i]

You want to choose a subset of stocks whose TOTAL cost does not exceed `saving`
and whose TOTAL profit is maximum. You cannot buy a stock with negative or zero
profit (equivalently, buying it contributes ≤ 0 to the total profit, so skip it).

Return the maximum achievable profit.

---------------------------------------------------------------------
Function form
int selectStock(int saving, vector<int> currentValue, vector<int> futureValue)

---------------------------------------------------------------------
Input format (for custom testing)
saving
n
currentValue[0]
currentValue[1]
...
currentValue[n-1]
n
futureValue[0]
futureValue[1]
...
futureValue[n-1]

Output
Single integer: the maximum profit.

Constraints
0 ≤ n ≤ 100
0 ≤ saving ≤ 30000
0 ≤ currentValue[i], futureValue[i] ≤ 300

---------------------------------------------------------------------
Example 1
Input
30
4
1
2
4
6
4
5
3
5
6
Output
6
Explanation: Buy stocks 1,2,3 → cost 1+2+4=7 ≤ 30, profit (5-1)+(3-2)+(5-4)=6.

Example 2
Input
250
5
175
133
109
210
97
5
200
125
128
228
133
Output
55
Explanation: Best is stocks at indices 2 and 5 → cost 109+97=206, profit 19+36=55.

Example 3
Input
500
5
150
199
200
168
153
5
140
175
199
121
111
Output
0
Explanation: All profits ≤ 0, so buy nothing.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Minimum Total Time at School with Skips

You have a schedule for n days, each day having m hourly slots (0..m-1).
The schedule is given as n binary strings of length m:
- '1' means there is a lecture at that hour on that day.
- '0' means no lecture.

If on a given day you attend at least one lecture, your time spent at school that day
equals (last_hour_attended - first_hour_attended + 1).
If you attend no lecture that day, the time spent is 0.

You may skip (i.e., delete) at most k lectures in total across all days
(turn up to k '1's anywhere in the matrix into '0').

Task
Choose which lectures to skip so that the sum of daily times is minimized.
Output that minimum total time.

Input Format
- First line: integer n — number of days.
- Next n lines: a binary string of equal length m for each day (implicitly gives m).
- Last line: integer k — total number of lectures you may skip.

Output Format
- One integer: the minimum possible total time after at most k skips.

Constraints
- 1 ≤ n, m, k ≤ 200
- Each string consists only of '0' and '1'
- All n strings have the same length m

Example
Input
4
0001
0101
0110
0000
3

Output
2

Explanation
Skip optimally: (day 0, hour 3), (day 1, hour 3), (day 2, hour 1).
Then times per day become 0, 1, 1, 0 → total = 2.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Number of ways

You are given the following:

• An integer Z
• An integer O
• An integer K

Task

Determine the number of binary strings with exactly Z zeroes and O ones such that
there are no K consecutive ones or zeroes in the string. As the number of strings
can be large, print the answer modulo 10^9 + 7.

Example

Assumptions

• Z = 2
• O = 2
• K = 2

Approach

In this example, there are two binary strings possible with exactly 2 zeroes and 2 ones
such that there are no two consecutive ones or zeroes.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Uber is partnered with N individual drivers, each driver has an ID from 1 to N.

For each pair of drivers with IDs i and j (1 ≤ i, j ≤ N), their similarity is
described by an integer S[i][j].

The similarity matrix S has the following properties:
- S[i][j] = S[j][i]  for all 1 ≤ i, j ≤ N
- S[i][i] = 0        for all 1 ≤ i ≤ N

Uber wants to divide the N drivers into some number of teams.
- Each driver must belong to exactly one team.
- After forming the teams, for each pair of drivers i and j (1 ≤ i < j ≤ N),
  the company reduces its efforts by S[i][j] points if drivers i and j belong
  to the same team.

Task:
Find the maximum possible total effort reduction Uber can achieve by
optimally dividing the drivers into teams.

Input:
- Integer N  (1 ≤ N ≤ 16)
- N × N integer matrix S, where:
    - -10^9 ≤ S[i][j] ≤ 10^9
    - S[i][i] = 0
    - S[i][j] = S[j][i]

Output:
- A 64-bit integer: the maximum total effort reduction.

Example 1
Input:
N = 3
S =
[  0   5   8
   5   0 -10
   8 -10   0 ]

Output:
8

Explanation:
The optimal division is {1, 3} and {2}. The only in-team pair (1, 3) contributes 8.

Example 2
Input:
N = 4
S =
[  0  10  10  10
  10   0  10  10
  10  10   0  -1
  10  10  -1   0 ]

Output:
49

Explanation:
The optimal division is a single team {1, 2, 3, 4}.
The sum of S[i][j] over all pairs in this team is 49.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


First subsequence

You are given the following:

• String A consisting of lowercase English letters.
• String B consisting of lowercase English letters.

You can change **at most one character** in string B, and this change
**cannot** be applied to the first character of B.

A string B is said to appear as a subsequence of A (under this rule) if you can:

• Choose positions i1 < i2 < … < i|B| in A,
• Such that A[i1] = B[0],
• For all other positions k (2 ≤ k ≤ |B|), either A[ik] = B[k-1], or for at
  most one of those positions A[ik] ≠ B[k-1] (this is where the single
  allowed change in B is used),
• And the relative order of characters of B in A is preserved.

Task
Determine the first (smallest) index in A (1-based) where such a subsequence
match of B can start. If no such subsequence exists, output -1.

Input format
• The first line contains an integer T, the number of test cases (1 ≤ T ≤ 10).
For each test case:
  – The first line contains string A (1 ≤ |A| ≤ 2000).
  – The second line contains string B (1 ≤ |B| ≤ 2000).

All strings consist only of lowercase English letters.

Output format
For each test case, print the answer on a new line: the first 1-based index in
A where B occurs as a subsequence with at most one change allowed in B (not on
its first character). If it is not possible, print -1.

Examples

Sample input
2
abcbc
cba
lhs
rhs

Sample output
3
-1

Explanation
Test case 1:
A = "abcbc", B = "cba".
The subsequences of A that can match B by changing at most 1 character are:
A[3], A[4], A[5] → "cbc" (requires changing B[3] from 'a' to 'c').
Thus the first occurrence starts at index 3. Answer: 3.

Test case 2:
A = "lhs", B = "rhs".
You cannot change the first character of B ('r'), and there is no subsequence
of A starting with 'r'. Hence it is impossible, so the answer is -1.

Another example
A = "daabe", B = "abe".
Possible matching subsequences by changing at most 1 character:
A[2], A[3], A[5] → "aae" (change B[2] from 'b' to 'a'),
A[2], A[4], A[5] → "abe" (no change),
A[3], A[4], A[5] → "abe" (no change).
The earliest start index is 2, so the answer is 2.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Alex loves movies and keeps track of their ratings, which can be either positive or negative integers.

Alex is preparing for a film festival and wants to choose a subsequence of movies that meets the following criteria:

• The total sum of their ratings is maximized.
• Alex must follow the list in order and cannot skip more than one movie consecutively.
  For instance, if ratings = [-1, -3, -2], the list must include either the second
  number or both the first and third numbers to achieve a maximal rating sum of -3.

Example
--------
ratings = [-3, 2, 4, -1, -2, -5]

The maximal choices are [2, 4, -2] for a sum of 4.

Function Description
--------------------
Complete the function maximizeRatings in the editor with the following parameter(s):

    int ratings[n]: movie ratings

Returns
-------
    int: the maximum possible rating sum for a subsequence of movies

Constraints
-----------
1 ≤ n ≤ 10^5
-1000 ≤ ratings[i] ≤ 1000, where 0 ≤ i < n


Sample Case 0
-------------

Sample Input 0
STDIN         Function
-----         --------
5             ratings[] size n = 5
9             ratings = [9, -1, -3, 4, 5]
-1
-3
4
5

Sample Output 0
17

Explanation 0
Alex picks the bolded items in ratings = [9, -1, -3, 4, 5] to get maximum rating
9 + (-1) + 4 + 5 = 17.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

In one operation on an array of integers:

• Choose any two adjacent elements.
• Insert the sum of the adjacent pair in their place.

Given an array of integers arr[n], perform this operation 0 or more times to create a non-decreasing array. Choose the operations to maximize the length of the resultant sorted array. Return that maximum length.

Example
n = 5
arr = [2, 4, 1, 6, 12]

Using 0-based indexing, choose arr[2] = 1 and arr[3] = 6. Replace the pair with their sum, 1 + 6 = 7, to yield [2, 4, 7, 12]. The array is non-decreasing and contains 4 elements. This is the longest result possible, so return 4.

Function Description
Complete the function optimalSumOperations in the editor below.

optimalSumOperations has the following parameter:
• int arr[n]: the array to sort

Returns
• int: the maximum length array one can obtain

Constraints
• 1 ≤ n ≤ 2 × 10^3
• 1 ≤ arr[i] ≤ 10^9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Harmonious Sequence – Minimum Removals

A sequence is considered harmonious if it can be divided into a series of groups, where each group has the following structure:

- The first element of the group is an integer k.
- This is followed by exactly k elements (any integers).
- After these k elements, a new group may start with its own leading integer, and so on.
- The sequence must end exactly at the end of a group (no leftover elements).

Examples:
- The sequence [3, 7, 2, 6, 2, 4, 4] is harmonious because it can be split into:
  [3, 7, 2, 6] and [2, 4, 4].
- The sequence [1, 8, 4, 5, 2, 6, 1] is harmonious because it can be split into:
  [1, 8] and [4, 5, 2, 6, 1].
- The sequence [3, 2, 1] is not harmonious.
- The empty sequence is considered harmonious.

You are given a sequence of integers A of length N.

In one operation, you may remove any single element from the sequence (from any position).

Task:
Determine the minimum number of operations (removals) required to make the sequence harmonious.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Forming Football Teams – Maximize Players

There are n players in a football club. The rating of the i-th player is Pi.

You are asked to form at most m teams with the following rule:

- For every team you form, the absolute difference between the ratings of
  any two players in that team must be at most 5.
  (Equivalently, in each team: max_rating - min_rating ≤ 5.)

Teams are independent of each other:
- The rating differences between players belonging to different teams do NOT matter.
- Each player can belong to at most one team.
- Some players may be left unused.

Your task:
Choose some players and partition them into no more than m valid teams
(satisfying the rating-difference condition) so that the total number of
players used is as large as possible.

Input:
- The first line contains two integers n and m
    n — number of players  (1 ≤ n ≤ 10^4)
    m — maximum number of teams allowed (1 ≤ m ≤ 10^3, m ≤ n)
- The second line contains n integers P1, P2, ..., Pn
    Pi — rating of the i-th player (1 ≤ Pi ≤ 10^5)

Output:
- Print a single integer: the maximum possible total number of players
  that can be picked to form no more than m teams.

Example:
Input:
6 2
33 5 8 20 17 3

Output:
5

Explanation:
Only 5 players can be used to form 2 valid teams.
One optimal way:
- Team 1: players with ratings 3, 5, 8 (max - min = 8 - 3 = 5 ≤ 5)
- Team 2: players with ratings 17, 20 (max - min = 20 - 17 = 3 ≤ 5)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Special Subsets

You are given an array a of size n.

Consider any subset S of indices from {0, 1, ..., n-1}.
Let T be the set of indices not chosen, i.e., T is the complement of S.

Define:
- sum(S) = sum of a[i] over all indices i in S.

A subset S is called special if the following condition holds:
For every index j in T:
    sum(S) ≥ a[j].

In other words, the total sum of the chosen elements must be at least as large as every single element that was not chosen.

Your task is to count how many subsets S are special.

Input:
- The first line contains a single integer n — the size of the array.
- The second line contains n integers a[0], a[1], ..., a[n-1].

Output:
- Print a single integer — the number of special subsets.

Constraints:
- 1 ≤ n
- 0 ≤ a[i]   (adjust bounds as needed)

Example:
Input:
4
1 2 3 4

Output:
X   (X is the count of special subsets for this example)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
