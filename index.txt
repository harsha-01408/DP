CODERE3 - Coder Express 3!!
#dynamic-programming #lds

There are N buildings in a line, each with a given height. Find the maximum length of a subsequence of buildings that first strictly increases and then strictly decreases (i.e., a bitonic subsequence with a single peak).

Input
The first line contains an integer T (1 ≤ T ≤ 100) — the number of test cases.
For each test case:
- A line with integer N (1 ≤ N ≤ 1000).
- A line with N integers A1, A2, …, AN (1 ≤ Ai ≤ 1000) — the heights.

Output
For each test case, print a single line with the maximum possible length of such a subsequence.

Example
Input:
2
10
1 3 5 6 4 8 4 3 2 1
6
8 6 3 4 2 1

Output:
9
5

Explanation
Test 1: One optimal subsequence is 1 3 5 6 8 4 3 2 1 (length 9).
Test 2: One optimal subsequence is 8 6 4 2 1 (length 5).



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Partition

You are given an array A of N integers (1-based indexing). You may split the array into any number K (K ≥ 1) of
contiguous partitions so that together they cover the whole array in order.

If the partition sums are P1, P2, …, PK, define the “special sum” of the partitioning as:
    P1 − P2 + P3 − P4 + … + (−1)^(K−1) · PK
(i.e., start with +, then alternate −, +, −, …).

Task
Choose a partitioning that maximizes the special sum and output that maximum value.

Notes
• Partitions must be contiguous and in order (no reordering of elements).
• 1-based indexing is assumed in any explanation.

Input Format
• The first line contains an integer N.
• The second line contains N space-separated integers A1, A2, …, AN.

Output Format
• Print a single integer: the maximum achievable special sum.

Constraints
• 1 ≤ N ≤ 10^5
• −10^5 ≤ Ai ≤ 10^6  for all i in [1, N]

Example
Input
5
-1 -2 3 2 9

Output
9

Explanation
One optimal partitioning is: [−1] | [−2, 3] | [2, 9]
Here, P1 = −1, P2 = (−2 + 3) = 1, P3 = (2 + 9) = 11
Special sum = P1 − P2 + P3 = (−1) − 1 + 11 = 9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The Abandoned City

You have N houses in a straight line; house i contains coins[i] (all positive).
You may start at any house and walk only in one direction (left or right) without
changing direction, stopping at any house. While walking, you collect coins from
every house you pass (including start and stop).

Find the **shortest distance** you must walk to collect **at least T coins**.
(“Distance” = number of houses visited = length of that contiguous segment.)
If it’s impossible (total coins < T), return -1.

Example:
coins = [1,2,3,4,5], T = 7
Minimum houses = 2 (e.g., houses [3,4] → 3+4=7).

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Maximum Strength After One Segment Swap

You are given two integer arrays A and B of equal length n. A superhero’s strength is 0 initially.
He will finally pick exactly ONE of the two arrays (after an optional operation described below)
and add up all elements of that chosen array — that total is his strength.

Before choosing the array, he may perform AT MOST ONE operation:
- Choose indices l and r (0 ≤ l ≤ r < n), and swap the subarray A[l..r] with B[l..r]
  (i.e., for every i in [l, r], swap A[i] and B[i]).

He can do this operation once or skip it. After that, he chooses either the resulting A or the
resulting B and his strength is the sum of all elements in that chosen array.

Task
Return the maximum possible strength he can obtain.

Input Format
- Line 1: integer n — length of the arrays.
- Line 2: n space-separated integers — A[0..n−1].
- Line 3: n space-separated integers — B[0..n−1].

Output Format
- A single integer: the maximum total obtainable after at most one subarray swap and then
  choosing the better of the two arrays.

Constraints
- 1 ≤ n ≤ 10^5
- 1 ≤ A[i], B[i] ≤ 10^4
- A and B have the same length.

Sample Input
5
20 40 20 70 30
50 20 50 40 20

Sample Output
220

Explanation
Swap the segment l=3, r=4 (0-based):
A becomes [20, 40, 20, 40, 20]  → sum = 140
B becomes [50, 20, 50, 70, 30]  → sum = 220
Choose B; maximum strength = 220.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Interleaving Subsequences Count

Given three lowercase strings p, q, and r (length ≤ 100), count the number of ways to form
exactly the string r by interleaving a subsequence of p and a subsequence of q, while
preserving the relative order of characters taken from each string. You must use at least
one character from p and at least one character from q. Return the answer modulo 1,000,000,007.

Notes
- “Subsequence” means you may skip characters but cannot reorder them.
- The two chosen subsequences (one from p, one from q) are interleaved to form r.
- At least one character must be taken from each of p and q.

Input Format
- Line 1: string p
- Line 2: string q
- Line 3: string r

Output Format
- A single integer: the number of valid interleavings modulo 1,000,000,007.

Constraints
- 1 ≤ |p|, |q|, |r| ≤ 100
- All strings consist only of lowercase English letters.

Sample
p: ab
q: ba
r: aba

Output:
2

Explanation:
Two valid ways to form "aba":
1) take "a" from p, then "ba" from q
2) take "ab" from p, then "a" from q

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Mortal Kombat — Max Coins

You are playing a simplified Mortal Kombat. You have:
• Your health: h
• Your per-hit damage: d

There are k opponents. For each opponent i (0 ≤ i < k):
• health hp[i]
• per-hit damage dmg[i]

Combat rules
• You may choose which opponents to fight and in what order. You can fight each opponent at most once.
• Fights are 1v1 and turn-based; YOU STRIKE FIRST in each turn.
  - On your turn, you deal d damage to the current opponent.
  - If the opponent is still alive, they strike back and deal dmg[i] damage to you.
  - Repeat until either you or the opponent dies.
• If you kill an opponent with health m, you earn m coins.
• The game ends immediately when your health becomes ≤ 0 (you die). You cannot start a new fight after that.

Task
Determine the maximum total number of coins you can earn by choosing a subset of opponents and an order to fight them, subject to not dying before finishing those fights.

Input Format
• First line: three integers h d k
• Second line: k integers hp[0..k-1]
• Third line: k integers dmg[0..k-1]

Output Format
• A single integer: the maximum coins obtainable.

Notes
• To kill opponent i you need hits_i = ceil(hp[i] / d) of your attacks.
• Since you strike first, they retaliate exactly hits_i − 1 times if you win.
• Thus, fighting i costs you (hits_i − 1) * dmg[i] health and yields hp[i] coins.
• You must remain alive before delivering each killing blow; equivalently, the total health you can afford to lose across chosen fights is at most h − 1.

Constraints
• 1 ≤ k ≤ 2 · 10^5  (typical; adjust as needed)
• 1 ≤ h, d ≤ 10^9
• 1 ≤ hp[i], dmg[i] ≤ 10^9

Example (illustrative)
h = 10, d = 4, k = 3
hp = 5 9 3
dmg = 3 4 10
Answer: 14
Explanation: Fight opponents with hp 5 and 9 (in that order). Costs: (ceil(5/4)-1)*3 = 3,
then (ceil(9/4)-1)*4 = 8; total cost 11 would kill you if done second first, so order matters.
The best feasible subset/order yields 5 + 9 = 14 coins.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Counting Jumps with B % (B − A) = 0

You can jump from an integer A to a larger integer B (A < B) iff:
    B % (B − A) = 0
(where % is modulo).

Starting from 1, count the number of distinct sequences of jumps to reach N.
Two sequences are different if at some step they go to different integers.

Because the count can be large, output it modulo 1,000,000,007.

Input Format
• The first line contains an integer T — the number of test cases.
• Each of the next T lines contains a single integer N.

Output Format
• For each test case, print the number of ways to reach N from 1 (mod 1e9+7).

Constraints
• 1 ≤ T ≤ 10000
• 1 ≤ N ≤ 100000

Notes
• The move rule is equivalent to: from x you may go to x + d for any divisor d of x.

Example
Input
4
1
2
3
4
Output
1
1
1
2
Explanation
N=1: already at 1 → 1 way.
N=2: 1→2.
N=3: 1→2→3 (1→3 is invalid since 3%(2)≠0).
N=4: paths are 1→2→4 and 1→2→3→4 → 2 ways.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Count Matching Subsequence Pairs

You are given two sequences:
• A of length N: A1 A2 … AN
• B of length M: B1 B2 … BM

A subsequence of a sequence is obtained by deleting zero or more elements without
changing the order of the remaining elements. Two subsequences taken from the
SAME sequence are considered different if they use different index positions,
even if their values are identical (i.e., we count by index choices). The empty
subsequence is allowed.

Task
Count the number of pairs (A_seq, B_seq) such that:
• A_seq is a subsequence of A,
• B_seq is a subsequence of B, and
• A_seq and B_seq are exactly the same sequence (same length and same elements
  in the same order).

Output the count modulo 1,000,000,007.

Input Format
• First line: two integers N M
• Second line: N integers A1 … AN
• Third line:  M integers B1 … BM

Constraints
• 1 ≤ N, M ≤ 3×10^3
• 1 ≤ Ai, Bi ≤ 10^5
• All values are integers.

Output Format
• Print a single integer — the number of valid pairs modulo 1e9+7.

Example
Input
2 2
2 7
7 2
Output
3
Explanation: Matching subsequences are (), (2), (7).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Construction Management (Paint House)

You are given a row of n houses. Each house must be built using exactly one of
three materials (A, B, or C). Adjacent houses may NOT use the same material.

For each house i (1 ≤ i ≤ n) you are given three integers:
  cost[i][0] = cost to build house i with material A
  cost[i][1] = cost to build house i with material B
  cost[i][2] = cost to build house i with material C

Task:
Choose a material for every house so that adjacent houses use different
materials and the total cost is minimized. Return the minimum total cost.

Input format
- First line: integer n
- Next n lines: three integers cost[i][0] cost[i][1] cost[i][2]

Output format
- One integer: the minimum total cost to build all houses.

Sample Input
3
17 2 17
16 16 5
14 3 19

Sample Output
10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Maximum Nutrition with Coupons

You have m units of money and n fruit varieties. For each fruit i (0 ≤ i < n):
  price[i]      – its cost (integer)
  nutrition[i]  – its nutrition value (integer)

You also have k discount coupons. A coupon can be applied to at most one fruit
and allows buying that fruit at half price (i.e., floor(price[i] / 2)).
Each fruit can be bought at most once, and at most one coupon can be used per fruit.

Task:
Choose a subset of fruits to buy and decide which (up to k) of them use a
coupon so that the total spent ≤ m and the sum of nutrition values is maximized.
Return that maximum total nutrition.

Input format
- First line: integer m
- Second line: integer n
- Third line: n space-separated integers price[0..n-1]
- Fourth line: n space-separated integers nutrition[0..n-1]
- Fifth line: integer k

Output format
- One integer: the maximum total nutrition achievable within budget m.

Constraints
1 ≤ m ≤ 10^3
1 ≤ n ≤ 500
1 ≤ price[i], nutrition[i] ≤ 10^3
0 ≤ k ≤ 10

Example 1
m = 4
n = 3
price      = [2, 4, 5]
nutrition  = [20, 17, 15]
k = 1
Optimal: buy fruit with price 2 at full price and fruit with price 4 using a
coupon (cost 2). Total cost = 2 + 2 = 4, total nutrition = 20 + 17 = 37.
Answer: 37

Example 2
m = 10
n = 2
price      = [10, 20]
nutrition  = [9, 10]
k = 1
Optimal: buy fruit 0 using a coupon (cost 5) and fruit 1 at full price (cost 10)
is too expensive; best is buy fruit 0 at full price (10) → nutrition 9, or use
coupon on fruit 1 (10) → nutrition 10. Maximum nutrition = 10.
Answer: 10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Element Swapping

Given an array arr of n integers, you may perform the following operation any number of times:
1) Choose an index i (0 ≤ i < n − 1) and swap arr[i] and arr[i + 1].
2) Each element can be swapped at most once during the whole process (i.e., no element participates in more than one swap).

The strength of index i is defined as arr[i] × (i + 1), using 0-based indexing.

Goal:
Find the maximum possible value of
    S = Σ_{i=0}^{n−1} arr[i] × (i + 1)
after applying allowed swaps optimally. Return this maximum.

Example
n = 4
arr = [2, 1, 4, 3]

Optimal swaps:
- swap(arr[2], arr[3])
- swap(arr[0], arr[1])

Final array: [1, 2, 3, 4]
Sum of strengths: 1×1 + 2×2 + 3×3 + 4×4 = 30
Return 30.

Function Description
Complete the function getMaximumSumOfStrengths with the parameter:
    int arr[n]: the initial array
Returns:
    long int: the maximum possible sum of strengths of all indices after optimal swaps.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Select Stock — Max Profit with Budget (0/1 Knapsack)

You have N stocks and a budget `saving`. You may buy at most ONE share of each
stock now at price `currentValue[i]`. After one year, stock i will be worth
`futureValue[i]`. If you buy stock i, your profit is:

    profit[i] = futureValue[i] - currentValue[i]

You want to choose a subset of stocks whose TOTAL cost does not exceed `saving`
and whose TOTAL profit is maximum. You cannot buy a stock with negative or zero
profit (equivalently, buying it contributes ≤ 0 to the total profit, so skip it).

Return the maximum achievable profit.

---------------------------------------------------------------------
Function form
int selectStock(int saving, vector<int> currentValue, vector<int> futureValue)

---------------------------------------------------------------------
Input format (for custom testing)
saving
n
currentValue[0]
currentValue[1]
...
currentValue[n-1]
n
futureValue[0]
futureValue[1]
...
futureValue[n-1]

Output
Single integer: the maximum profit.

Constraints
0 ≤ n ≤ 100
0 ≤ saving ≤ 30000
0 ≤ currentValue[i], futureValue[i] ≤ 300

---------------------------------------------------------------------
Example 1
Input
30
4
1
2
4
6
4
5
3
5
6
Output
6
Explanation: Buy stocks 1,2,3 → cost 1+2+4=7 ≤ 30, profit (5-1)+(3-2)+(5-4)=6.

Example 2
Input
250
5
175
133
109
210
97
5
200
125
128
228
133
Output
55
Explanation: Best is stocks at indices 2 and 5 → cost 109+97=206, profit 19+36=55.

Example 3
Input
500
5
150
199
200
168
153
5
140
175
199
121
111
Output
0
Explanation: All profits ≤ 0, so buy nothing.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Minimum Total Time at School with Skips

You have a schedule for n days, each day having m hourly slots (0..m-1).
The schedule is given as n binary strings of length m:
- '1' means there is a lecture at that hour on that day.
- '0' means no lecture.

If on a given day you attend at least one lecture, your time spent at school that day
equals (last_hour_attended - first_hour_attended + 1).
If you attend no lecture that day, the time spent is 0.

You may skip (i.e., delete) at most k lectures in total across all days
(turn up to k '1's anywhere in the matrix into '0').

Task
Choose which lectures to skip so that the sum of daily times is minimized.
Output that minimum total time.

Input Format
- First line: integer n — number of days.
- Next n lines: a binary string of equal length m for each day (implicitly gives m).
- Last line: integer k — total number of lectures you may skip.

Output Format
- One integer: the minimum possible total time after at most k skips.

Constraints
- 1 ≤ n, m, k ≤ 200
- Each string consists only of '0' and '1'
- All n strings have the same length m

Example
Input
4
0001
0101
0110
0000
3

Output
2

Explanation
Skip optimally: (day 0, hour 3), (day 1, hour 3), (day 2, hour 1).
Then times per day become 0, 1, 1, 0 → total = 2.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Number of ways

You are given the following:

• An integer Z
• An integer O
• An integer K

Task

Determine the number of binary strings with exactly Z zeroes and O ones such that
there are no K consecutive ones or zeroes in the string. As the number of strings
can be large, print the answer modulo 10^9 + 7.

Example

Assumptions

• Z = 2
• O = 2
• K = 2

Approach

In this example, there are two binary strings possible with exactly 2 zeroes and 2 ones
such that there are no two consecutive ones or zeroes.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Uber is partnered with N individual drivers, each driver has an ID from 1 to N.

For each pair of drivers with IDs i and j (1 ≤ i, j ≤ N), their similarity is
described by an integer S[i][j].

The similarity matrix S has the following properties:
- S[i][j] = S[j][i]  for all 1 ≤ i, j ≤ N
- S[i][i] = 0        for all 1 ≤ i ≤ N

Uber wants to divide the N drivers into some number of teams.
- Each driver must belong to exactly one team.
- After forming the teams, for each pair of drivers i and j (1 ≤ i < j ≤ N),
  the company reduces its efforts by S[i][j] points if drivers i and j belong
  to the same team.

Task:
Find the maximum possible total effort reduction Uber can achieve by
optimally dividing the drivers into teams.

Input:
- Integer N  (1 ≤ N ≤ 16)
- N × N integer matrix S, where:
    - -10^9 ≤ S[i][j] ≤ 10^9
    - S[i][i] = 0
    - S[i][j] = S[j][i]

Output:
- A 64-bit integer: the maximum total effort reduction.

Example 1
Input:
N = 3
S =
[  0   5   8
   5   0 -10
   8 -10   0 ]

Output:
8

Explanation:
The optimal division is {1, 3} and {2}. The only in-team pair (1, 3) contributes 8.

Example 2
Input:
N = 4
S =
[  0  10  10  10
  10   0  10  10
  10  10   0  -1
  10  10  -1   0 ]

Output:
49

Explanation:
The optimal division is a single team {1, 2, 3, 4}.
The sum of S[i][j] over all pairs in this team is 49.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


First subsequence

You are given the following:

• String A consisting of lowercase English letters.
• String B consisting of lowercase English letters.

You can change **at most one character** in string B, and this change
**cannot** be applied to the first character of B.

A string B is said to appear as a subsequence of A (under this rule) if you can:

• Choose positions i1 < i2 < … < i|B| in A,
• Such that A[i1] = B[0],
• For all other positions k (2 ≤ k ≤ |B|), either A[ik] = B[k-1], or for at
  most one of those positions A[ik] ≠ B[k-1] (this is where the single
  allowed change in B is used),
• And the relative order of characters of B in A is preserved.

Task
Determine the first (smallest) index in A (1-based) where such a subsequence
match of B can start. If no such subsequence exists, output -1.

Input format
• The first line contains an integer T, the number of test cases (1 ≤ T ≤ 10).
For each test case:
  – The first line contains string A (1 ≤ |A| ≤ 2000).
  – The second line contains string B (1 ≤ |B| ≤ 2000).

All strings consist only of lowercase English letters.

Output format
For each test case, print the answer on a new line: the first 1-based index in
A where B occurs as a subsequence with at most one change allowed in B (not on
its first character). If it is not possible, print -1.

Examples

Sample input
2
abcbc
cba
lhs
rhs

Sample output
3
-1

Explanation
Test case 1:
A = "abcbc", B = "cba".
The subsequences of A that can match B by changing at most 1 character are:
A[3], A[4], A[5] → "cbc" (requires changing B[3] from 'a' to 'c').
Thus the first occurrence starts at index 3. Answer: 3.

Test case 2:
A = "lhs", B = "rhs".
You cannot change the first character of B ('r'), and there is no subsequence
of A starting with 'r'. Hence it is impossible, so the answer is -1.

Another example
A = "daabe", B = "abe".
Possible matching subsequences by changing at most 1 character:
A[2], A[3], A[5] → "aae" (change B[2] from 'b' to 'a'),
A[2], A[4], A[5] → "abe" (no change),
A[3], A[4], A[5] → "abe" (no change).
The earliest start index is 2, so the answer is 2.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Alex loves movies and keeps track of their ratings, which can be either positive or negative integers.

Alex is preparing for a film festival and wants to choose a subsequence of movies that meets the following criteria:

• The total sum of their ratings is maximized.
• Alex must follow the list in order and cannot skip more than one movie consecutively.
  For instance, if ratings = [-1, -3, -2], the list must include either the second
  number or both the first and third numbers to achieve a maximal rating sum of -3.

Example
--------
ratings = [-3, 2, 4, -1, -2, -5]

The maximal choices are [2, 4, -2] for a sum of 4.

Function Description
--------------------
Complete the function maximizeRatings in the editor with the following parameter(s):

    int ratings[n]: movie ratings

Returns
-------
    int: the maximum possible rating sum for a subsequence of movies

Constraints
-----------
1 ≤ n ≤ 10^5
-1000 ≤ ratings[i] ≤ 1000, where 0 ≤ i < n


Sample Case 0
-------------

Sample Input 0
STDIN         Function
-----         --------
5             ratings[] size n = 5
9             ratings = [9, -1, -3, 4, 5]
-1
-3
4
5

Sample Output 0
17

Explanation 0
Alex picks the bolded items in ratings = [9, -1, -3, 4, 5] to get maximum rating
9 + (-1) + 4 + 5 = 17.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

In one operation on an array of integers:

• Choose any two adjacent elements.
• Insert the sum of the adjacent pair in their place.

Given an array of integers arr[n], perform this operation 0 or more times to create a non-decreasing array. Choose the operations to maximize the length of the resultant sorted array. Return that maximum length.

Example
n = 5
arr = [2, 4, 1, 6, 12]

Using 0-based indexing, choose arr[2] = 1 and arr[3] = 6. Replace the pair with their sum, 1 + 6 = 7, to yield [2, 4, 7, 12]. The array is non-decreasing and contains 4 elements. This is the longest result possible, so return 4.

Function Description
Complete the function optimalSumOperations in the editor below.

optimalSumOperations has the following parameter:
• int arr[n]: the array to sort

Returns
• int: the maximum length array one can obtain

Constraints
• 1 ≤ n ≤ 2 × 10^3
• 1 ≤ arr[i] ≤ 10^9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Harmonious Sequence – Minimum Removals

A sequence is considered harmonious if it can be divided into a series of groups, where each group has the following structure:

- The first element of the group is an integer k.
- This is followed by exactly k elements (any integers).
- After these k elements, a new group may start with its own leading integer, and so on.
- The sequence must end exactly at the end of a group (no leftover elements).

Examples:
- The sequence [3, 7, 2, 6, 2, 4, 4] is harmonious because it can be split into:
  [3, 7, 2, 6] and [2, 4, 4].
- The sequence [1, 8, 4, 5, 2, 6, 1] is harmonious because it can be split into:
  [1, 8] and [4, 5, 2, 6, 1].
- The sequence [3, 2, 1] is not harmonious.
- The empty sequence is considered harmonious.

You are given a sequence of integers A of length N.

In one operation, you may remove any single element from the sequence (from any position).

Task:
Determine the minimum number of operations (removals) required to make the sequence harmonious.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Forming Football Teams – Maximize Players

There are n players in a football club. The rating of the i-th player is Pi.

You are asked to form at most m teams with the following rule:

- For every team you form, the absolute difference between the ratings of
  any two players in that team must be at most 5.
  (Equivalently, in each team: max_rating - min_rating ≤ 5.)

Teams are independent of each other:
- The rating differences between players belonging to different teams do NOT matter.
- Each player can belong to at most one team.
- Some players may be left unused.

Your task:
Choose some players and partition them into no more than m valid teams
(satisfying the rating-difference condition) so that the total number of
players used is as large as possible.

Input:
- The first line contains two integers n and m
    n — number of players  (1 ≤ n ≤ 10^4)
    m — maximum number of teams allowed (1 ≤ m ≤ 10^3, m ≤ n)
- The second line contains n integers P1, P2, ..., Pn
    Pi — rating of the i-th player (1 ≤ Pi ≤ 10^5)

Output:
- Print a single integer: the maximum possible total number of players
  that can be picked to form no more than m teams.

Example:
Input:
6 2
33 5 8 20 17 3

Output:
5

Explanation:
Only 5 players can be used to form 2 valid teams.
One optimal way:
- Team 1: players with ratings 3, 5, 8 (max - min = 8 - 3 = 5 ≤ 5)
- Team 2: players with ratings 17, 20 (max - min = 20 - 17 = 3 ≤ 5)


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Special Subsets

You are given an array a of size n.

Consider any subset S of indices from {0, 1, ..., n-1}.
Let T be the set of indices not chosen, i.e., T is the complement of S.

Define:
- sum(S) = sum of a[i] over all indices i in S.

A subset S is called special if the following condition holds:
For every index j in T:
    sum(S) ≥ a[j].

In other words, the total sum of the chosen elements must be at least as large as every single element that was not chosen.

Your task is to count how many subsets S are special.

Input:
- The first line contains a single integer n — the size of the array.
- The second line contains n integers a[0], a[1], ..., a[n-1].

Output:
- Print a single integer — the number of special subsets.

Constraints:
- 1 ≤ n
- 0 ≤ a[i]   (adjust bounds as needed)

Example:
Input:
4
1 2 3 4

Output:
X   (X is the count of special subsets for this example)

------------------------------------------------------------

Follow-up 1: Sum of Subset Sums over Special Subsets

Keep the same definitions of a, S, T, and special subsets as in Problem 1.

Instead of just counting how many subsets S are special, you must now compute:
    F1 = Σ sum(S)
over all special subsets S.

That is, for every special subset S, take sum(S), and then sum these values over all such S.

Input:
- Same as Problem 1.

Output:
- Print a single integer:
    F1 = sum of sum(S) over all special subsets S.


------------------------------------------------------------
Follow-up 2: Sum of Subset Products over Special Subsets

Again, keep the same definitions of a, S, T, and special subsets as in Problem 1.

Define:
- prod(S) = product of a[i] over all indices i in S.
- By convention, for the empty subset ∅, define prod(∅) = 1.

Now you must compute:
    F2 = Σ prod(S)
over all special subsets S.

That is, for every special subset S, take prod(S), and then sum these values over all such S.

Input:
- Same as Problem 1.

Output:
- Print a single integer:
    F2 = sum of prod(S) over all special subsets S.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


You are given a garden represented by a binary string s, where:
- '0' = rose
- '1' = cosmos

A flower shop sells two types of bouquets:

- Type 1: one rose → revenue p
- Type 2: one rose + one cosmos → revenue q

Bouquets must be formed using consecutive flowers in the string.

- A Type-1 bouquet uses a single '0'.
- A Type-2 bouquet uses a substring "01" or "10" (any consecutive rose–cosmos pair).

You may choose any disjoint consecutive segments of the string.  
Each flower can be used in at most one bouquet.  
You do not have to use all flowers.

Your task is to maximize the total revenue from the bouquets you form and
return (or print) this maximum revenue.

Constraints
1 ≤ p, q ≤ 1000
1 ≤ |s| ≤ 10^5

Input
The first line contains two integers p and q.
The second line contains the binary string s.

Output
Print a single integer – the maximum total revenue.

Example
Input
2 3
00101000

Output
5


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Maximum Subarray Sum with One Replacement

Given two arrays a and b of n integers, you can replace at most one 
element a[i] with b[i]. Find the maximum sum of a contiguous subarray 
after performing this operation (or not performing it).

Input:
- First line: integer n (1 ≤ n ≤ 10^5)
- Second line: n integers a[1], a[2], ..., a[n]
- Third line: n integers b[1], b[2], ..., b[n]

Output:
- Single integer: maximum subarray sum

Example:
Input:
3
10 -100 10
1 1 1

Output:
21

Explanation:
Replace a[2]=-100 with b[2]=1, giving array [10, 1, 10].
The maximum subarray sum is 10 + 1 + 10 = 21.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Maximum Subarray Sum with One Boost

Given two arrays a and b of n integers each. You can update at most 
one element by setting a[i] = a[i] + b[i]. Find the maximum sum of a 
contiguous subarray after performing this operation (or not performing it).

Input:
- First line: integer n (1 ≤ n ≤ 10^5)
- Second line: n integers a[1], a[2], ..., a[n] (-10^9 ≤ a[i] ≤ 10^9)
- Third line: n integers b[1], b[2], ..., b[n] (-10^9 ≤ b[i] ≤ 10^9)

Output:
- Single integer: maximum subarray sum

Example:
Input:
3
5 -10 5
0 20 0

Output:
20


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Maximum Subarray Sum with Unlimited Boosts

Given two arrays a and b of n integers each. For each index i, you can 
independently choose to update a[i] = a[i] + b[i] or leave it unchanged.
Find the maximum sum of a contiguous subarray after performing any 
number of such operations.

Input:
- First line: integer n (1 ≤ n ≤ 10^5)
- Second line: n integers a[1], a[2], ..., a[n] (-10^9 ≤ a[i] ≤ 10^9)
- Third line: n integers b[1], b[2], ..., b[n] (-10^9 ≤ b[i] ≤ 10^9)

Output:
- Single integer: maximum subarray sum

Example:
Input:
3
5 -10 5
0 20 -3

Output:
20

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Maximum Subarray Sum with K Boosts

Given two arrays a and b of n integers each. You can update at most k 
elements by setting a[i] = a[i] + b[i] (each index can be chosen at 
most once). Find the maximum sum of a contiguous subarray.

Input:
- First line: integers n, k (1 ≤ n ≤ 10^5, 0 ≤ k ≤ n)
- Second line: n integers a[1], a[2], ..., a[n] (-10^9 ≤ a[i] ≤ 10^9)
- Third line: n integers b[1], b[2], ..., b[n] (-10^9 ≤ b[i] ≤ 10^9)

Output:
- Single integer: maximum subarray sum

Example 1:
Input:
5 2
5 -10 5 -10 5
0 20 0 20 0

Output:
35

Explanation: Boost a[1] and a[3] to get [5, 10, 5, 10, 5]. 
             Maximum subarray sum = 5 + 10 + 5 + 10 + 5 = 35.

Example 2:
Input:
3 1
10 -100 10
1 1 1

Output:
21

Explanation: Boost a[1] to get [10, -99, 10]. 
             Maximum subarray sum = 21? No wait...
             Actually boost a[1]: -100 + 1 = -99, still bad.
             Better: just take subarray [10] or [10], ans = 10.
             
             Hmm, let's reconsider with replacement version:
             If it's a[i] = b[i] (replace), then [10, 1, 10] → 21.

Example 3:
Input:
4 2
-5 -5 -5 -5
10 10 10 10

Output:
10

Explanation: Boost a[0] and a[1] to get [5, 5, -5, -5].
             Maximum subarray sum = 5 + 5 = 10.

Constraints:
- 1 ≤ n ≤ 10^5
- 0 ≤ k ≤ n
- -10^9 ≤ a[i], b[i] ≤ 10^9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Maximum Subarray Sum with K Replacements

Given two arrays a and b of n integers each. You can replace at most k 
elements by setting a[i] = b[i] (each index can be chosen at most once). 
Find the maximum sum of a contiguous subarray.

Input:
- First line: integers n, k (1 ≤ n ≤ 10^5, 0 ≤ k ≤ n)
- Second line: n integers a[1], a[2], ..., a[n] (-10^9 ≤ a[i] ≤ 10^9)
- Third line: n integers b[1], b[2], ..., b[n] (-10^9 ≤ b[i] ≤ 10^9)

Output:
- Single integer: maximum subarray sum

Example 1:
Input:
5 2
5 -10 5 -10 5
0 20 0 20 0

Output:
45

Explanation: Replace a[1]=20, a[3]=20 to get [5, 20, 5, 20, 5].
             Maximum subarray sum = 55.

Example 2:
Input:
3 1
10 -100 10
1 1 1

Output:
21

Explanation: Replace a[1]=1 to get [10, 1, 10].
             Maximum subarray sum = 10 + 1 + 10 = 21.

Constraints:
- 1 ≤ n ≤ 10^5
- 0 ≤ k ≤ n
- -10^9 ≤ a[i], b[i] ≤ 10^9



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array gems of integers representing the values of gems in a row, and three integers p, q, r.
You can remove up to p single gems, up to q pairs of consecutive gems, and up to r triplets of consecutive gems. The removals are of disjoint consecutive segments in the original array.
The goal is to minimize the sum of the remaining gems after performing the removals.
Example 1:
Input: gems = [8,5,4,2,0,7,-8,-100,1], p = 1, q = 1, r = 1
Output: -107
Explanation: One possible way:

Remove single gem 8.
Remove pair [5,4].
Remove triplet [2,0,7].
Remaining: [-8,-100,1], sum = -107.

Constraints:

1 <= gems.length <= 100
0 <= p, q, r <= 10
gems[i] is an integer (can be positive, negative, or zero).
The total gems removed (p + 2q + 3r) <= gems.length.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem -

You have N power sockets numbered 1..N. You start at socket 1 and want to reach socket N.

For each socket i (1 ≤ i ≤ N), four boolean arrays A, B, C, D describe which actions are allowed from socket i:

- If A[i] = 1: you may stay at the same socket i (i -> i).
- If B[i] = 1: you may move from socket i to socket i+1 (i -> i+1), if i+1 ≤ N.
- If C[i] = 1: you may move from socket i to socket i+2 (i -> i+2), if i+2 ≤ N.
- If D[i] = 1: you may jump back to socket 1 (i -> 1).

Not all sockets support all actions (arrays can differ per i).

Task:
Count the total number of distinct ways to direct power from socket 1 to socket N using exactly K sockets/steps (i.e., exactly K moves/transitions).
Since the answer can be large, return it modulo 998244353.

Input format:
- First line: integer N (number of sockets/nodes)
- Second line: integer K (number of steps)
- Next N lines: A[1..N] (each line is 0 or 1)
- Next N lines: B[1..N]
- Next N lines: C[1..N]
- Next N lines: D[1..N]

Output:
- One integer: number of valid paths from 1 to N in exactly K steps, modulo 998244353.

Constraints (from screenshot):
- 1 ≤ N ≤ 1e5
- 1 ≤ K ≤ 1e5

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

New Network Protocol

A string must be transferred using a custom network protocol.
The protocol processes the string as follows:

• Each pair of characters in the string is processed together.
• If any pair contains matching characters (e.g., "aa"), it requires an additional sameTime seconds.
• The string can be split into substrings before transmission, with each partition adding partitionTime seconds.

Calculate the minimum possible total extra time required, which is the sum of:
• Time for processing pairs with matching characters.
• Time for creating partitions.

Example
s = "abcabcc"
sameTime = 1
partitionTime = 4

Two optimal approaches are:
1. Split into ["abc", "abcc"]
   - "abc" has no matching pairs: 0 seconds
   - One partition: 4 seconds
   - "abcc" has one "cc" pair: 1 second
   - Total: 0 + 4 + 1 = 5 seconds
2. Keep s ["abcabcc"]
   - 5 matching pairs ("ab", "bc", "ca", "ab", "bc", "cc"): 5 seconds
   - Total: 5 seconds

The minimum possible extra time is 5 seconds.

Function Description
Complete the function getMinimumTime in the editor with the following parameters:
• string s: the string to transfer
• int sameTime: the extra time taken to process a pair of matching characters
• int partitionTime: the extra time to partition a string

Returns
• int: the minimum possible total extra time to transfer the string s over the network

Constraints
• 1 ≤ length of s ≤ 2500
• 1 ≤ sameTime, partitionTime ≤ 10^5

Input Format for Custom Testing
The first line contains an integer sameTime.
The second line contains an integer partitionTime.
The third line contains a string s.

Sample Case 0
Sample Input 0
5
1
abbaa

Sample Output 0
2

Explanation
An optimal partition: ["ab", "ba", "a"]
total extra time = extraTime("ab") + partitionTime + extraTime("ba") + partitionTime + extraTime("a")
                = 0 + 1 + 0 + 1 + 0
                = 2

Sample Case 1
Sample Input 1
5
5
aaa

Sample Output 1
10

Explanation
An optimal partition: ["aa", "a"]
total extra time = extraTime("aa") + partitionTime + extraTime("a")
                = 5 + 5 + 0
                = 10

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The Christmas Gift

You are given N ingredients. Each ingredient i has a taste score ai (1..10).
CodeChef will make ONE dish for EVERY subset of these N ingredients (including the empty subset).

For any subset D (the ingredients included in the dish):
- Planet A pays: (sum of scores in D) - (sum of scores NOT in D)
- Planet B pays: (sum of scores NOT in D) - (sum of scores in D)

Each dish (subset) must be sent to exactly ONE planet (A or B), not both.

Goal:
Choose, for every subset, whether to send it to Planet A or Planet B, to maximize the total money earned
over all 2^N dishes.

Output the maximum total money modulo 10^7 for each test case.

Input:
T test cases.
For each test case:
- N
- N integers a1..aN (taste scores)

Output:
For each test case, print the maximum total modulo 10^7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


You have n cities in a line.

population[i] = how many people live in city i (1-based).

unit[i] is a binary string:

'1' means city i currently has a security unit,

'0' means it doesn’t.

You may move any security unit at city i > 1 one step left to city i-1.

Each unit can be moved at most once.

If you move it, city i loses the unit and city i-1 gains it.

A unit in city 1 cannot move.

After you finish moving units, a city is protected if it has at least one unit.

Goal: choose which units (if any) to move so that the sum of populations in protected cities is as large as possible.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Palindrome Triplets

Problem
You are given a lowercase string S of length n.

A "good triplet" is a choice of three substrings of S such that:
- Each chosen substring is a palindrome, and
- The three substrings do not overlap and appear from left to right.

More formally, choose three index pairs:
P1(i1, j1), P2(i2, j2), P3(i3, j3)
such that:
0 <= i1 <= j1 < i2 <= j2 < i3 <= j3 < n
and the substrings:
S[i1..j1], S[i2..j2], S[i3..j3]
are all palindromes.

Task
For each test case, compute how many good triplets exist.

Notes
- 0-based indexing is used.
- A substring is a contiguous part of the string.
- A palindrome reads the same forward and backward.

Input Format
- The first line contains an integer T (number of test cases).
- For each test case:
  - The first line contains an integer n.
  - The second line contains the string S.

Output Format
For each test case, print a single integer: the number of good triplets.

Constraints
1 <= T <= 5
1 <= n <= 10^3
S contains only lowercase English letters.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given three integers AA, AB and BB. These represent the number of blocks you have:
- "AA" (AA copies),
- "AB" (AB copies),
- "BB" (BB copies).

You may concatenate some or all of these blocks (each block can be used at most as many times as available)
to build a string.

The resulting string must NOT contain the substring "AAA" and must NOT contain the substring "BBB".

Write a function:
  string solution(int AA, int AB, int BB)
that returns any string of maximum possible length that can be built under these rules.
If multiple maximum-length strings exist, you may return any of them.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array arr of length n containing positive integers.

A partition splits the array into one or more contiguous, non-empty subsegments that together cover
the entire array (each element belongs to exactly one subsegment).

For any partition, compute the sum of each subsegment in left-to-right order, producing a sequence
of sums. The partition is considered valid if the parity of these sums alternates, i.e., every pair
of adjacent subsegment sums has different parity (one is even and the other is odd).

Two partitions are different if there exists at least one array element that belongs to a different
subsegment in the two partitions.

Return the number of valid partitions of arr, modulo 10^9 + 7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given several delivery requests along a straight road.

Each request i has:
- a pickup position start[i]
- a drop-off position end[i]
- an extra reward premium[i]

When a request is completed, the courier earns:
(end[i] − start[i]) units for the distance traveled
plus premium[i] units as a bonus.

Rules:
- The courier can deliver only one package at a time.
- The courier always moves forward and never travels backward.
- While delivering a package from start[i] to end[i], the courier cannot start
  or finish any other delivery whose location lies within that interval.

Choose a set of delivery requests that can be completed without violating these
rules and that yields the maximum possible total earnings.

Output the maximum total earnings.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array A of length N and an integer X.

Define the cost of an array as the sum of its elements.

You may perform the following operation any number of times:
- Choose any contiguous subarray of the current array whose element-sum is
  divisible by X, and delete that entire subarray.

After deletions, the remaining elements join together to form a shorter array.

Your task is to minimize the final cost (sum of the remaining elements) after
performing zero or more valid deletions.

Because the answer can be large, output it modulo 10^9 + 7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Time Limit: 2 sec / Memory Limit: 1024 MiB

Let N be a positive integer.  
You are given a string s of length N−1 consisting only of the characters '<' and '>'.

Find the number of permutations (p1, p2, …, pN) of the numbers (1, 2, …, N) that satisfy the following condition:

For each i (1 ≤ i ≤ N−1):
- pi < p(i+1) if the i-th character of s is '<'
- pi > p(i+1) if the i-th character of s is '>'

Since the answer can be large, output it modulo 10^9 + 7.

Constraints:
- 2 ≤ N ≤ 3000
- s is a string of length N−1
- s consists only of '<' and '>'

Input:
N  
s

Output:
Print the number of valid permutations modulo 10^9 + 7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Time Limit: 2 sec / Memory Limit: 1024 MiB
Score: 600 points

Problem Statement:
Given an integer sequence A₁, A₂, ..., Aₙ of length N.

You must choose exactly ⌊N/2⌋ elements from this sequence such that
no two chosen elements are adjacent.

Find the maximum possible sum of the chosen elements.

Here ⌊x⌋ denotes the greatest integer not greater than x.

Constraints:
2 ≤ N ≤ 2 × 10⁵
|Aᵢ| ≤ 10⁹
All values are integers.

Input:
N
A₁ A₂ ... Aₙ

Output:
Print the maximum possible sum of the chosen elements.

Sample Input 1:
6
1 2 3 4 5 6

Sample Output 1:
12

Sample Input 2:
5
-1000 -100 -10 0 10

Sample Output 2:
0

Sample Input 3:
10
1000000000 1000000000 1000000000 1000000000 1000000000
1000000000 1000000000 1000000000 1000000000 1000000000

Sample Output 3:
5000000000

Sample Input 4:
27
18 -28 18 28 -45 90 -45 23 -53 60 28 -74 -71 35 -26 -62
49 -77 57 24 -70 -93 69 -99 59 57 -49

Sample Output 4:
295

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array A of N integers.
You must split the array into exactly K non-empty contiguous segments.

For each segment:
- Let S be the sum of the elements in the segment.
- Let L be the number of elements in the segment.
- The cost of the segment is | S − L × D |.

The total cost of a partition is the sum of the costs of all K segments.

Your task is to find the minimum possible total cost over all valid partitions.

Input:
N
K
D
A1 A2 ... AN

Output:
The minimum total cost.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

You are given an array A of size N. The cost of the array is defined as the sum of its elements.

You may perform the following operation any number of times:
- Delete any contiguous subarray whose sum is divisible by X.

Your task is to find the minimum possible cost of the array after performing the operation optimally.
Since the result can be large, return the answer modulo 10^9 + 7.

Input Format
- The first line contains an integer N, the number of elements in the array.
- The second line contains an integer X, the given divisor.
- The next N lines each contain one integer representing A[i].

Constraints
- 1 ≤ N ≤ 10^5
- 1 ≤ X ≤ 10^6
- 1 ≤ A[i] ≤ 10^6

Sample Input
2
2
1
1

Sample Output
0

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

You are given a connected tree consisting of n nodes.

A tree is called a Hamilton Tree if there exists a single simple path
that visits all n nodes exactly once.

You may perform the following operation any number of times:

• Remove any one edge from the tree, which splits it into two components.
• Add a new edge between any node from the first component and any node
  from the second component, restoring the tree structure.

Determine the minimum number of such operations required to convert
the given tree into a Hamilton Tree.

Input Format
• An integer n — the number of nodes.
• n−1 lines follow, each containing two integers u and v
  representing an edge between nodes u and v.

Output Format
• Output a single integer — the minimum number of operations needed.

Constraints
• The graph is initially a tree.
• 1 ≤ n

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

You are given a grid of integers with n rows and m columns. Rows are numbered from top
to bottom and columns from left to right.

In one operation, you may choose any element in the grid and divide it by a positive
integer d. The cost of this operation is d. You may perform any number of operations on
any element.

A path from cell (1, 1) to cell (n, m) is formed by moving only right or down. A path is
called valid if all the numbers on that path are nice.

An integer is called nice if the total number of its divisors is equal to
2^(number of its distinct prime divisors).

For example:
3, 6, and 7 are nice integers,
while 8, 9, and 12 are not nice integers.

Your task is to find the minimum total cost of operations required to make at least one
valid path in the grid.


Input Format

The first line contains an integer n, the number of rows.
The second line contains an integer m, the number of columns.
The next n lines each contain m space-separated integers describing the grid.


Constraints

1 ≤ n ≤ 100
1 ≤ m ≤ 100
1 ≤ a[i][j] ≤ 10^9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

You are given a string s of length n.

In one operation, you may:
- remove one character from the string, and
- insert it at any position in the string.

Your goal is to make all equal characters contiguous, meaning:
- each distinct character must appear in exactly one continuous block,
- the order of these blocks can be chosen arbitrarily.

Example:
  s = "abac"
  Valid target forms include: "aabc", "bbccaa", etc.
  (same multiset of characters, one block per letter)

Task:
Find the minimum number of operations required to transform s
into such a valid string.

Notes:
- The final string must contain the same characters with the same frequencies.
- Moving a character counts as exactly one operation.

Constraints:
- n can be large
- number of distinct characters ≤ 10

Output:
- a single integer: the minimum number of operations needed

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Hacker's Team

A cybersecurity firm is forming a team by selecting hackers from two groups,
Team A and Team B. Both teams have the same number of hackers, and the skill
levels are given in two arrays, team_a and team_b.

At each position i, exactly one hacker can be chosen — either from Team A or
from Team B.

A team is considered strong if the selected skill levels form a
non-decreasing sequence.

Your task is to find the maximum length of a contiguous subarray [l..r]
such that it is possible to choose one hacker from either team_a or team_b
at each index in this range, and the resulting sequence of skills is
non-decreasing.

Function to implement:
getMaxSubarrayLen(team_a, team_b)

Inputs:
- team_a (int[]): skill levels of Team A
- team_b (int[]): skill levels of Team B

Output:
- int: the maximum length of a subarray that can form a strong team

Example:
team_a = [5, 2, 4, 1]
team_b = [3, 6, 2, 2]

One possible selection for indices [1..3]:
Choose [2, 2, 2], which is non-decreasing.

Result:
3

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Description

You are given an array `blocks`, where each element represents the performance
score of a data block.

You are also given:
- numZones: the exact number of contiguous zones to divide the array into
- queryLimit: for each zone, only the largest `queryLimit` values contribute
  to that zone’s score

Rules for splitting:
- The array must be split into exactly `numZones` zones
- Each zone must be a contiguous subarray
- Zones must not overlap
- Every element must belong to exactly one zone
- Zones must preserve the original order of the array

Scoring:
- For each zone:
  - Select the `queryLimit` largest values in that zone
  - Sum them to get the zone’s score
- The total system performance is the sum of all zone scores

Goal:
Determine how to split the array into `numZones` contiguous zones such that
the total system performance is maximized.

Return the maximum possible total score.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array B of beacon intensities.

You move from left to right and choose some beacons.
You do not need to choose consecutive beacons, but the order must be kept.

You start in Phase A.
After each chosen beacon, the phase switches between A and B.

If you choose a beacon with value x:

Phase A:
You cannot choose any later beacon whose value is
strictly greater than x and strictly less than 2x.

Phase B:
You cannot choose any later beacon whose value is
strictly greater than x/2 and strictly less than x.

Your goal is to choose beacons so that the total number
of chosen beacons is as large as possible.

Output the maximum number of beacons you can choose.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given a line of n beads. Each bead has two integer values:

- strength S[i]
- preservation P[i]

You must split the entire line into one or more contiguous segments (chains).  
Every bead must be used exactly once.

A segment from index L to R (0-based, inclusive) is valid only if BOTH:

1. (max_strength - min_strength)^2 < sum of preservation values in the segment  
   i.e. (max(S[L..R]) - min(S[L..R]))² < sum(P[L..R])

2. The number of beads in the segment where P[i] < S[i] is even  
   (count of such beads in [L..R] % 2 == 0)

The value/profit of one valid segment [L..R] is:  
sum(S[L..R]) - max(P[L..R])

Goal:  
Find a partition of the entire array into contiguous valid segments  
that maximizes the sum of their values (total profit).

Output:  
The maximum possible total value (a single integer).

Input format (assumed):  
First line: n  
Second line: n integers S[0] S[1] ... S[n-1]  
Third line: n integers P[0] P[1] ... P[n-1]

Constraints (typical, not given):  
1 ≤ n ≤ 5000 (for O(n²) DP to pass)  
Values of S[i], P[i] usually fit in 32-bit int, but use long long for sums.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


You have n particles arranged in a line, indexed from 0 to n-1.  
Each particle has an intensity value I[i].

When you decide to pick particle i, it generates a trail value:  
trail_i = I[i] % (i + 3)

After picking particle i, any later particle j (j > i) becomes unstable  
and cannot be picked if the following condition is true:

((I[j] XOR I[i]) % 6) == trail_i

You process the particles strictly from left to right (index 0 to n-1).  
For each particle, if it is not yet unstable, you may either:  
- pick it, or  
- skip it.

Once a particle becomes unstable (due to any previously picked particle),  
you cannot pick it when you reach its position.

The order of picked particles must be strictly increasing (preserves left-to-right order).

Goal:  
Find the maximum number of particles you can pick without violating the instability rules.

Output:  
A single integer — the size of the largest possible set of particles you can select.

Input format (standard assumption):  
First line: integer n  
Second line: n integers I[0] I[1] ... I[n-1]

Typical constraints:  
1 ≤ n ≤ 5000  
I[i] are non-negative integers (usually fit in 32-bit signed int)

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given a weighted, undirected road graph with nodes 1..N and edges (u, v, w).

There are M companies. Company i owns a set of nodes (locations). If you choose (contract) a company,
you must place drop-off centers at all nodes owned by that company.

Given a minimum distance D, a subset of companies is valid if for every pair of drop-off centers
created by the chosen companies, the shortest-path distance between their nodes in the road graph
is at least D.

Count how many subsets of companies are valid (including the empty subset unless stated otherwise).

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are playing a game with n bosses arranged in a fixed order from 1 to n.  
You must defeat the bosses strictly in this order.

The i-th boss deals damage a[i] to you.

You have a special ability that can be activated at most k times.

When the special ability is active:
- You become a SuperHero.
- You take NO damage from any boss while fighting under this activation.

Once activated, the ability remains active across consecutive boss fights, but it automatically deactivates if the following condition becomes true:

- The GCD (Greatest Common Divisor) of the damage values a[i] of all bosses defeated during the current activation becomes equal to 1.

The ability deactivates only AFTER the boss that causes the GCD to become 1 is defeated.
Damage is still zero for that boss.

After deactivation, you may activate the ability again if you still have remaining activations.

Your task is to determine the minimum total damage you will take after defeating all n bosses, using the special ability at most k times.

Input:
- An integer n, the number of bosses.
- An integer k, the maximum number of times the special ability can be activated.
- An array a of length n, where a[i] is the damage dealt by the i-th boss.

Output:
- A single integer representing the minimum total damage taken.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given n servers arranged in a sequence, numbered from 1 to n.
Data upload starts from a central server labeled 0 and must reach server n.

Each server i (1 ≤ i ≤ n) introduces a delay of delay[i] units when the data
packet is processed at that server.

From any server i, the data packet can be transmitted forward to any server
j such that i < j ≤ i + k (at most k servers ahead).

The delay of a server is added only when the packet reaches that server.
Assume delay[0] = 0.

Your task is to compute the minimum total delay required to reach server n
from server 0.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem Description

You are given a network of nodes labeled 0..N, where node 0 is a gateway.

There are two types of undirected edges:

1) Ring edges  
   For nodes 1..N, there is a cycle:
   - Edge between node i and node i+1 for i = 1..N-1
   - Edge between node N and node 1  
   Removing the ring edge (i, i+1) has cost ring[i]
   (ring[N] is the cost for edge (N,1))

2) Gateway edges  
   For each node i = 1..N, there is an edge between node 0 and node i  
   Removing edge (0, i) has cost gateway[i]

You may remove (disable) any edges, paying their respective costs.

Your goal is to remove a set of edges with minimum total cost such that
the remaining graph can be divided into exactly two security groups
(i.e., the graph is bipartite).

Equivalently:
- Each node must be assigned one of two colors.
- Every remaining edge must connect nodes of different colors.
- Any edge connecting two nodes of the same color must be removed.

Input
-----
N
ring[1..N]
gateway[1..N]

Output
------
The minimum total cost of edges that must be removed so that the
remaining graph is bipartite.

Notes
-----
- Node 0 is the gateway.
- ring[i] is the cost to remove edge (i, i+1) for i < N,
  and ring[N] is the cost to remove edge (N,1).
- gateway[i] is the cost to remove edge (0,i).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
